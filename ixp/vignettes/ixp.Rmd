---
title: "IXP"
author: "Joe Peskett"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(ixp)
```

## Loading ixp data

There are five data sets included within the package that can be called using `ixp::lon2` or any other ixp name. The names of ixps are `lon1, lon2, man1, car1, sco1, nva1`.These come with weekday and minutes since midnight columns included. It is advisable to smooth this data, usually with the `smooth_and_clean()` function. This takes a univariate xts object, example shown below:

```{r}
lon2_smoothed <- smooth_and_clean(my_data = lon2$Bandwidth)
lon2_smoothed <- lon2_smoothed["2016/2017"]
```

Additional arguments can be made to this, indluding subsetting by a specific date or alternating the n for simple moving average smoothing.

## Manipulating IXP data

Manipulating the ixp data:

Once the data is in the correct and smoothing has been applied, if required, functions can be used to compare the distance and size of the two peaks in the afternoon or the rate of increase in bandwidth consumption in the morning. These can be calculated using either `peak_finder()` for the peaks or `feature_finder()` for the rate of morning increase. You can subset the data using standard xts subsetting if required, however these have been optimised to run fairly quickly on this data.

```{r}
peaks <- peak_finder(lon2_smoothed)
features <- feature_frame(lon2_smoothed)
```

As well as taking an xts object, you can also specify the windows that you’re looking for peaks in with the `peak_finder()`, or the multipliers that you’re interested in with `feature_finder()`. These have good default values for the analyses we need so far. The multipliers may need to be altered depending on the scale of increase in the morning. Multipliers are passed as a vector(advised to include a multiplier of 1 to find the trough) whlie the windows are passed as a list.

It is likely that you will then want to take a given date or collection of dates to analyse the peaks. For this you can use the function `select_dates()`. This function takes a date or vector of dates and returns a function that takes a list of either peaks or features and returns just the values for the dates selected. Example is given below:

```{r}
may_5_16 <- select_date(date = "2016-05-05")
features %>% may_5_16()
peaks %>% may_5_16()
```

For the peaks, this provides us with all the information we might need for any particular date or dates. However when it comes to the `feature_frame()` we might want to start looking at the differences in gradients. For this, there is another function that is used called `gradients()`. This is called after `time_2_increase`. A demonstration is shown below:

```{r}
features %>% may_5_16() %>% time_2_increase()
```
This quite clearly shows the difference between the multipiers for the given date. This will also work for multiple dates as shown below.

```{r}
my_dates <- seq(as.Date("2016-01-01"), as.Date("2016-01-31"), by = 7)
jan_16 <- select_date(my_dates)
features %>% jan_16() %>% time_2_increase()

```

One stage further, gradients can be calculated:

```{r}
features %>% jan_16() %>% time_2_increase %>% gradients()
```

The output from this can be made a bit nicer by using unlist with recursive set to FALSE. 

```{r}
unlist(features %>% jan_16() %>% time_2_increase %>% gradients(), recursive = F)
```

If you want to collapse this into a matrix then you can use the example code below. 

```{r}
all_dates_16 <- select_date(date = seq(as.Date("2016-01-01"), as.Date("2016-12-31"), by = 1))
mat_16 <- do.call(rbind, unlist(features %>%
                              all_dates_16() %>%
                              time_2_increase() %>%
                              gradients(), recursive = F, use.names = F))
head(mat_16, n = 10)
```

## Plotting functions 

These functions allow you to plot single days with either the lines for either the rate of increase of the two peaks. These host the the `peak_finder` or `feature_frame` functions.

```{r}
par(mfrow = c(2,1))
peak_plot(lon2_smoothed["2016"], date = "2016-06-06")
feature_plot(lon2_smoothed["2016"], date ="2016-06-06")
```

## Other utility functions

In parts of this project I have looked at using an LSTM, which requires the data to be formatted in quite a specific way. If you want to use sequences to train the network a 3D array is required. Your inputs are one dimension, the second is the sequeces and the final dimension is for the features. So if you have 10 training inputs, 3 features and each input has a sequence of length 4 you will have a 10x4x3 array. We have used an array using the previous l points to predict the next point. If l was 3 we'd have an array looking like this:
```{r}
matrix(c(1,2,3,2,3,4,3,4,5,4,5,6,5,6,7), ncol = 3, byrow = T)
```

Doing this using loops can be quite time consuming so there are a couple of functions included that can be useful here. You pass some univariate xts object to the `tstep_lag()` function. This will create a function that then takes an integer of any length (less than length of the dataset!). 

```{r}
index_data <- tstep_lag(data = lon2_smoothed["2016-01"]$Bandwidth)
cut_data <- subset_wrap(data = lon2_smoothed["2016-01"]$Bandwidth)
train_x <- index_data(288)%>%cut_data()
```




